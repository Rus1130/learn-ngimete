
<head>
    <style>
        .table-container {
            display: flex;
            gap: 20px;
            align-items: flex-start;
        }

        .quality-table {
            border-collapse: collapse;
            font-family: sans-serif;
            font-size: 13px;
            margin: 20px;
            width: auto;
            min-width: 300px;
        }

        .quality-table th,
        .quality-table td {
            border: 1px solid #ccc;
            padding: 6px 10px;
            text-align: center;
            width: auto;
        }

        .quality-table th {
            background: #eee;
            font-weight: 600;
        }

        .quality-table tr:nth-child(even) {
            background: #f9f9f9;
        }

        #word-quality-table td:nth-child(2) {
            text-align: right;
            font-family: monospace;
        }
        #word-quality-table td:nth-child(3) {
            text-align: center;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <div class="table-container">
        <table id="sound-qualities-table" class="quality-table">
            <tr>
                <th>Sound</th>
                <th>Sharpness</th>
                <th>Form</th>
                <th>Affinity</th>
            </tr>
        </table>
        <table id="word-quality-table" class="quality-table">
            <tr>
                <th>Word</th>
                <th>Quality Diagram</th>
                <th>Element Count</th>
                <th>Affinity</th>
            </tr>
        </table>
    </div>
</body>
<script type="module">
    import { dict } from './dictionary.js';
    import { Writer } from './lib.js';

    const letter_table = {
         "f": { q1:  0.8, q2: -0.5 },
         "v": { q1:  1  , q2: -1   },
         "p": { q1: -0.3, q2:  0.3 },
         "b": { q1: -0.5, q2:  0.5 },
         "t": { q1: -0.5, q2:  0.5 },
         "d": { q1: -0.7, q2: -0.3 },
         "c": { q1: -0.5, q2:  0.2 },
         "k": { q1: -1  , q2:  1   },
         "ɡ": { q1: -0.7, q2: -0.9 },
         "ʔ": { q1:  0  , q2:  0   },
        "ᵐb": { q1: -0.2, q2:  0.2 },
        "ⁿd": { q1:  1,   q2:  1   },
        "ᵑɡ": { q1: -0.9, q2: -0.9 },
         "m": { q1:  0.3, q2:  0.8 },
         "n̪": { q1:  0.4, q2:  0.8 },
         "ŋ": { q1: -1,   q2: -1   },
         "s": { q1:  0.3, q2: -0.1 },
         "h": { q1:  0.7, q2: -0.4 },
        "t͡s": { q1:  0.8, q2:  0.8 },
         "w": { q1:  0.1, q2: -0.3 },
         "j": { q1:  0.3, q2: -0.7 },
         "l": { q1: -0.4, q2: 0.2  },
        
    }

    const affinity_table = structuredClone(letter_table);

    // clear all the values in affinity_table
    for(let letter in affinity_table) {
        affinity_table[letter] = {};
    }

    function getOppositeQuality(quality){
        if(quality == "Fire") return "Water";
        if(quality == "Water") return "Fire";
        if(quality == "Earth") return "Metal";
        if(quality == "Metal") return "Earth";
    }

    let words = [];

    function addSound(sound, quality1, quality2, affinity) {
        let table = document.getElementById("sound-qualities-table");
        let row = table.insertRow(-1);

        row.insertCell(0).textContent = sound;
        row.insertCell(1).textContent = quality1;
        row.insertCell(2).textContent = quality2;
        row.insertCell(3).textContent = affinity;
    }

    function determineMainAffinity(q1, q2){
        if (Math.sign(q1) == -1 && Math.sign(q2) == -1) {
            return "Water";
        } 
        else if (Math.sign(q1) == -1 && Math.sign(q2) == 1) {
            return "Earth";
        } 
        else if (Math.sign(q1) == 1 && Math.sign(q2) == -1) {
            return "Fire";
        } 
        else if (Math.sign(q1) == 1 && Math.sign(q2) == 1) {
            return "Metal";
        } else {
            return "None";
        }
    }

    const shortcuts = {
        "Fire": "F",
        "Water": "W",
        "Earth": "E",
        "Metal": "M",
        "Strong": "!",
        "Weak": "~",
        "Balanced": "=",
        "None": "0"
    }

    function determineFireOrWater(q1){
        return Math.sign(q1) == 1 ? "Fire" : "Water";
    }
    function determineEarthOrMetal(q2){
        return Math.sign(q2) == 1 ? "Metal" : "Earth";
    }

    for(let letter in letter_table) {
        let qualities = letter_table[letter];
        let mainAffinity = "";
        let sideAffinity = "";

        let q1 = qualities.q1;
        let q2 = qualities.q2;

        // --- Determine main element by sign combo ---
        mainAffinity = determineMainAffinity(q1, q2);

        affinity_table[letter].main = mainAffinity;
        affinity_table[letter].sharpness = q1
        affinity_table[letter].form = q2

        // --- Strong vs Weak (based on magnitude) ---
        let strength = (Math.abs(q1) + Math.abs(q2)) / 2; // average magnitude
        let strengthLabel = strength > 0.5 ? "Strong" : "Weak";

        affinity_table[letter].strength = strengthLabel;
        affinity_table[letter].influence = "None"

        let fullMainAffinity = strengthLabel + " " + mainAffinity;

        // --- Side element: whichever axis has smaller magnitude ---
        // get the difference between the absolute values of q1 and q2
        let diff = Math.abs(Math.abs(q1) - Math.abs(q2));

        if(diff == 0) {
            sideAffinity = "(Balanced)"
            affinity_table[letter].influence = "Balanced";
        } else {
            if(strengthLabel == "Weak"){
                sideAffinity = Math.min(q1, q2);

                let sideAffinitySource = Math.min(q1, q2) == q1 ? "q1" : "q2";

                if(sideAffinitySource == "q1") sideAffinity = determineFireOrWater(q1);
                else sideAffinity = determineEarthOrMetal(q2);

                affinity_table[letter].influence = sideAffinity;

                sideAffinity = `(${sideAffinity} Influence)`;
            }
        }

        let totalAffinity = `${fullMainAffinity} ${sideAffinity}`;

        if(fullMainAffinity.includes(mainAffinity) && sideAffinity.includes(mainAffinity)) {
            totalAffinity = fullMainAffinity;
        }

        if(q1 == 0 && q2 == 0) totalAffinity = "None";

        addSound(letter, qualities.q1, qualities.q2, totalAffinity);
    }

    const consonants = ["n̪","t͡s","ᵐb","ⁿd","ᵑɡ","f","v","p","b","t","d","c","k","ɡ","ʔ","m","ŋ","s","h","w","j","l"]
    const vowels = ["ɑː","aː","oː","uː","iː","eː","i","y","u","e","ə","o","a","ɑ"]

    function tokenizeSyllable(syllable) {
        let sounds = [];
        let i = 0;

        // sort once outside the loop for efficiency
        const sortedConsonants = [...consonants].sort((a, b) => b.length - a.length);
        const sortedVowels = [...vowels].sort((a, b) => b.length - a.length);

        while (i < syllable.length) {
            if (syllable[i] === ".") {  
                // skip dots
                i++;
                continue;
            }

            let match = null;

            // Try consonants (longest first)
            for (let c of sortedConsonants) {
                if (syllable.startsWith(c, i)) {
                    match = c;
                    break;
                }
            }

            // Try vowels (longest first)
            if (!match) {
                for (let v of sortedVowels) {
                    if (syllable.startsWith(v, i)) {
                        match = v;
                        break;
                    }
                }
            }

            if (match) {
                sounds.push(match);
                i += match.length;
            } else {
                // fallback: single character
                sounds.push(syllable[i]);
                i++;
            }
        }

        return sounds;
    }

    function addWord(word, quality, elementCount, affinity) {
        let table = document.getElementById("word-quality-table");
        let row = table.insertRow(-1);

        row.insertCell(0).textContent = word;
        row.insertCell(1).innerHTML = quality;
        row.insertCell(2).innerHTML = elementCount;
        row.insertCell(3).textContent = affinity;
    }

    function getWordElementModifier(count){
        if(count < 2) return "Weak";
        else if(count < 4) return "Balanced";
        else if(count < 6) return "Slightly Strong";
        else if(count < 8) return "Strong";
        else if(count < 12) return "Very Strong";
        else return "Extremely Strong";
    }

    dict.waitForDictLoad().then(() => {
        // filter out these categories from dict.dict: Connecting letters, vowel sounds, consonant sounds, grammar, phrases, pronouns, dont add, tenses
        let excludedCategories = ["Connecting Letters", "Vowel Sounds", "Consonant Sounds", "Grammar", "Phrases", "Pronouns", "dont add", "Tenses", "Numerals", "Miscellaneous", "Interrogatives"];
        for (let category in dict.dict) {
            if(excludedCategories.includes(category)) continue;
            words.push(...dict.dict[category])
        }

        const elementCounts = {};

        words.forEach(word => {
            let ipa = new Writer(word.value.Standard).ipa().replaceAll(/[\[\]]/g, "");

            let sounds = tokenizeSyllable(ipa);

            let qualityDiagram = []

            let qualities = [];
            let shorthandQualities = [];

            let startedWithVowel = false;

            let wordAffinityCounts = {
                "Fire": 0,
                "Water": 0,
                "Earth": 0,
                "Metal": 0
            }

            sounds.forEach((phoneme, i) => {
                let table = affinity_table[phoneme];

                if(table){
                    let sharpness = table.sharpness;
                    let form = table.form;

                    qualities.push([sharpness, form])

                    let qd = `<span title='(${sharpness}, ${form})'>###</span>`;


                    let main = table.main;

                    if(main == "None") shorthandQualities.push("0");
                    else {
                        let strength = table.strength;
                        let influence = table.influence;

                        let shorthand = `${shortcuts[strength]}${shortcuts[main]}`;

                        if(influence == "Balanced") shorthand += "=";
                        else if(influence != "None") shorthand += "&lt;" + shortcuts[influence];

                        // replace (letter)<(letter) with (letter)
                        shorthand = shorthand.replace(/([FWEM])&lt;\1/, "$1");

                        qd = qd.replace("###", shorthand)

                        
                        qualityDiagram.push(qd);
                    }

                    if(main != "None"){
                        wordAffinityCounts[main] += 2;
                        if(table.strength == "Strong") wordAffinityCounts[main]++;
                        if(table.influence != "None" && table.influence != "Balanced") {
                            wordAffinityCounts[table.influence] += 0.5;
                        }
                    }

                    elementCounts[word.key] = wordAffinityCounts;
                } else if(vowels.includes(phoneme)) {
                    if(i == 0) startedWithVowel = true;
                    qualityDiagram.push(`[${phoneme}]<br>`)
                }
            })

            let affinity = "";

            if(qualities.length < 2 || startedWithVowel) {
                affinity = "INVALID SPELL"

                addWord(word.key, qualityDiagram.join(" "), "---", affinity);
            } else {
                // get the top 2 elements from wordAffinityCounts
                let sortedAffinities = Object.entries(wordAffinityCounts).sort((a, b) => b[1] - a[1]);
                let primary = sortedAffinities[0];
                let secondary = sortedAffinities[1];

                let elementCount = `E:${wordAffinityCounts["Earth"]} M:${wordAffinityCounts["Metal"]} F:${wordAffinityCounts["Fire"]} W:${wordAffinityCounts["Water"]}`

                if(secondary[1] == 0){
                    let primaryModifier = getWordElementModifier(primary[1]);
                    affinity = `${primaryModifier} True ${primary[0]}`;

                } else {
                    let diff = primary[1] - secondary[1];
                    let primaryModifier = getWordElementModifier(primary[1]);
                    let secondaryModifier = getWordElementModifier(secondary[1] - 2);
                    affinity = `${primaryModifier} ${primary[0]} (${secondaryModifier} ${secondary[0]})`;
                }

                addWord(word.key, qualityDiagram.join(" "), elementCount, affinity);
            }

            
        })
    });
</script>